---
title: "数据库索引"
date: 2022-06-15T21:41:48+08:00
draft: false
tag: MySQL
---



如果你遇到一条执行很慢的sql，分析完原因之后你很有可能采用的方案就是”建索引“。索引的功能就是为了加快查询，类型目录一样，然后在几百页的书本中快速找到你想看的内容。

### 索引的常用模型

为了提高读写的数据结构有很多，常见的有三种：哈希表、有序数组、搜索树。

**哈希表**是一种以键-值（key-value）存储数据的结构。使用数组来保存值，经过对键的hash运算得到这个值应该放的位置。当然，我们知道不同的内容通过hash运算后可能会重复，那么这时候就在数组后面拉出一个链表。

假如你现在在维护一个身份证信息的表，对应的hash表结构：

![哈希表](http://www.zerowzl.com/images/1547618866202.jpg)

我们发现id_card_01和id_card_02的身份证号hash运算之后是一样的，那么在存储的时候他们都会放到一个索引位上，然后通过链表的方式来存储。如果这时候你要通过id_card_03查询user_03，步骤大致是这样的，将id_card_03经过hash运算得到值n，找到索引位后，通过遍历链表的方式拿到user_03。

需要注意的是，上面存储身份证时并不是递增的，这样的好处是每次新增只需要让后面加，因此存储快。但由于没有顺序，导致无法进行范围查询，如果你要查询两个身份证中间所有的值，必须要走全表扫描。

**所有哈希表这种数据结构适合等值查询的情况**比如Memcached。

而**有序数组在等值和范围查询场景中的性能都非常优秀**，有序数组在上面的例子中的体现：

![有序数组](http://www.zerowzl.com/images/1547619035877.jpg)

在存储一组没有重复数据的场景下，数据在存储的时候就已经排好了顺序，这样如果你想查询两个身份证之间所有的用户，那么可以使用两分查找，得到第一个值，然后向大的一方遍历，直到最后一个大于上限的值。这时的时间复杂度可以达到O(log(n))。

但是有序数组在插入一条新数据时需要挪动后面所有受影响的数据，因此适合用来处理静态的数据。

二叉搜索树：

![二叉搜索树](http://www.zerowzl.com/images/1547619086268.jpg)

二叉搜索树的特点是每个左节点都小于父节点，每个右节点都大于父节点。每个父节点下有两个子节点。如果你还是查询id_card_03的user_03，那么搜索路径就是userA -> userE -> userF -> user_03，时间复杂度是0(log(n))。为了维持查询的O(log(n))的时间复杂度，更新的时间复杂度也是0(log(n))。

树有二叉，当然也有N叉。二叉树是搜索搜索效率最高的，但是数据库索引却不使用二叉树，原因是数据不仅存储在内存中，还要写在磁盘上。二叉树由于每个节点的子节点都是两个，那么如果数据量太大，树就会变得非常高。因此产生的IO访问就会很多，从而导致查询时间很慢。由于是二叉树的结构，很难遇到一个节点和其两个子节点刚好相邻。

那么为了减少磁盘IO访问，数据库的索引使用的就是N叉树。这里的N取决于数据块的大小。以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，差不多是17亿。考虑到树根的数据库总是在内存中，一个10亿行的表上的一个整数字段的索引，查找一个值最多只需要访问磁盘3次。

N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，依旧被广泛应用在数据库引擎中。（也有跳表、LSM树），技术都在不断发展啊。

在接触一个新技术（框架）时，先要了解其底层的数据结构，这样才能从理论上分析出这个技术（框架)的适用场景。

### InnoDB的索引模型

MySQL中，索引是在引擎层实现的，所以没有统一的标准。在InnoDB中，**表都是根据主键顺序以索引的形式存放的，这这种存储方式的表称为索引组织表**。InnoDB使用的是B+树索引模型，因此**数据都是存在B+树中**的。**每一个索引在InnoDB里面对应一颗B+树**。

一个表有id（主键），k（索引），name三个字段。

```sql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

表中的R1-R5的(id,k)值分为了(100,1)、(200,2)、(300,3)、(500，5)、(600,6)，下图是两个索引的示意图：

![索引示意图](http://www.zerowzl.com/images/1547622850878.jpg)

我们可以发现，id索引（主键索引，也叫聚簇索引（clustered index)）的叶子节点保存的是这一行的数据，k索引（非主键索引，也被称为二级索引(secondary index)）的叶子节点保存的是id的值。

因为这两个索引存储的内容不同，我们来看一下使用两个索引的流程是怎样的？

- 如果查询语句是select * from T where id = 300; 即主键查询方式，只需要搜索主键索引树就可以得到结果。
- 如果查询语句是select * from T where k = 3;即普通索引查询方式，则先需要查信息k索引树，得到主键的值，再去主键索引树搜索一次得到结果。这个过程称为回表。

可以看出，基于普通索引的查询方式，会多一步回表的操作，因此我们应该尽量使用主键查询的方式。

### 索引维护

B+树为了维护索引的有序性，在插入的时要做必要的维护。如果插入值比当前的最大值大，直接在后面插入一个新值，比较简单。如果插入的值是在中间，那就比较麻烦了。需要挪动比他大的值。

比较糟糕的情况是，如果由于临近较大值的数据页满了，根据B+树的算法，这时候要申请一个新的数据页，然后挪动部分数据过去。这个过程被称为页分裂。是会影响性能的。

除了影响性能，还会影响数据页的。原本一块数据页的数据现在被分到了两个页上，整体利用率下降50%。

当然有页分裂，就有页合并。页合并发生在相邻两个页由于删除了数据，利用率很低之后，会将数据页进行合并。可以理解为页分裂的逆过程。

>  哪些场景适合用自增主键？哪些场景不适合？

自增相互缉拿是指自增列上定义的主键，在建表语句中一般这么定义的：NOT NULL PRIMARY KEY AUTO_INCREMENT。

插入新记录不需要指定主键的值，系统会根据当前表中ID最大值做+1操作。

也就是说，自增主键的插入模式，正符合我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，不涉及到挪动其他的记录，也不会发生叶子节点的分裂。

而又业务逻辑的字段做主键，则往往不容易保存有序插入，这样写数据成本相对较高。

除了从性能角度考虑外，从存储空间考虑是否适合使用身份证作为主键。如果使用身份证字符串作为主键，那么其他普通索引的叶子节点的空间大小就是20字节，而如果是用整型就是4节点，长整型就是8(bitint)字节。

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**

所以，从性能和存储空间的角度考虑，自增主键往往是更合理的选择。

适合用业务字段作为主键的：

- 只有一个索引
- 该索引必须是唯一索引

这是一个典型的kv场景。由于没有其他索引，不需要考虑其他索引的叶子节点大小的问题。正和符合前面说的查询尽量使用主键的原则。

### 思考题：

重建索引，SQL分别是：

```sql
普通索引：
alter table T drop index k;
alter table T add index(k);
主键：
alter table T drop primary key;
alter table T add primary key(id);

```

为什么需要重建索引：索引可能因为删除，或者页分裂等原因，导致数据也有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高。也就是索引更紧凑、更省空间。

重建索引k的做法是合适的，但是不论删除主键索引还是创建主键，都会将整个表重建。如果连着执行着两个语句的话，第一个语句就白做了。可以使用alter table T engine=InnoDB代替。

### 覆盖索引

我们知道普通索引存储的数据是主键的值，如果一条SQL语句的where 条件的字段是一个普通索引，返回字段是* 或者不是主键的字段，那么执行流程大致是

1. 搜索普通索引树得到主键的值v1
2. 到主键搜索树拿到主键v1的行内容

如果是范围查询会重复上面两步直到不满足条件的值。这个过程是回表，那么就像在前面定义的条件中说的，如果你要查询是主键，那么这时候是不需要回表的，因为主键的值就在普通索引搜索树上。这个情况被称为“**覆盖索引**”，即通过一个索引树的搜索就获取了你要查询的内容。

因为覆盖索引可以减少回表（搜索次数），显著提升查询性能，因此使用覆盖索引就是一种常用的性能优化手段。

### 最左前缀匹配原则

B+树这种数据结构可以利用索引的“最左匹配”，来定位数据。比如你的数据是这样的：

![昵称和年龄索引示例](http://www.zerowzl.com/images/1547715774239.jpg)

首先，节点上的数据是按照顺序排列的；

假如一条SQL是这样的select name,age from user where name like 'b%'；那么这条SQL符合最左前缀匹配原则，可以使用索引，首先得到user3，然后向右遍历取出所有符合要求的数据。

**这个最左匹配原则可以是联合索引的最左的N个字段，也可以是字符串索引的最M个字符。**

### 联合索引

那么基于覆盖索引的特点，我们来看下如何合理的使用联合索引进而提升查询的性能。

案例：是否有必要在下面这张市民表上创建身份证和姓名的联合索引？

```sq
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

如果现在有一个高频请求根据身份证号码查询用户姓名，那么这个联合索引是有必要的，因为这时候可以使用覆盖索引，避免回表，从而提高查询性能。

当然索引的维护是需要付出成本的，这里有点像用空间换时间。如何抉择需要权衡思考。这正是架构师和DBA的工作。

##### 几个原则

1. 尝试通过调整联合索引的顺序，从而可以减少索引数量的维护。即索引的复用能力。
2. 假如已有（a，b）联合索引，根据最左匹配原则，不需要再维护一个a索引；不过如果联合查询，又有基于两个字段单独的查询，这时候（a，b）联合索引可以满足基于a的查询，但需要再维护一个b索引。那么成本考虑，如果两个字段的查询频次差不多，既有联合又有单独的查询，那么单独维护的那个空间较小的字段。

### 索引下推

MySQL5.6引入了索引下推优化。大致流程是这样的：

以上面的市民表为例：

```sq
mysql> select * from tuser where name like '张 %' and age=10 and ismale=1;
```

在执行这条SQL时，会走(name,age)联合索引树，获取第一条符合条件"张"的记录，这时候先不回表，会先过滤掉age不符合的记录。减少了回表的次数。

ps:感觉这个功能很合理，不知道为什么MySQL在5.6才引入此功能。

### 思考题：

```sql
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;

```

查询语句：

```sql
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```



ca 和 cb索引是否有必要？

根据覆盖索引的原理，c索引树节点的内容是这样的(c,a,b)，ca索引树节点内容是这样的(c,a,b)，cb索引树节点是这样的(c,b,a)。因为在创建索引树的时候，树上的数据都已经经过排序。我们发现，c索引和ca索引其实存的内容是一样的，可以使用最左匹配原则，那么ca就可以去掉了。cb保留。

