---
title: "普通索引和唯一索引，应该怎么选择？"
date: 2022-06-15T21:25:48+08:00
draft: false
tag: MySQL
---


以下的衡量标准都是通过性能考虑的。

### 查询过程

前提：已经通过业务代码保证了数据库不会存在两条相同的数据。

那么普通索引和唯一索引查询的过程如下：

1. 根据索引树获取到数据所在的数据页，我们可以理解成在数据页内部通过两分法获取到第一条满足条件的记录。
2. 如果是唯一索引，拿到数据直接返回。如果是普通索引，需要多查一次获取到不满足的数据。

那么，多查了一次对性能的影响有多大呢？**微乎其微！**

首先，我们知道InnoDB中数据都是按页分配和查询的（查询到的这一行记录所在的数据页都会存在内存中），索引的下一行数据一般都会在同一个数据页中。一个数据页的大小是16KB。一个数据页可以存在近千个整型的索引，所有出现不在一个数据页的可能性很小。



### 更新过程

先讨论更累过程前，首先我们要知道change buffer。在需要更新一个数据页时，如果数据页在内存中则直接更新，如果一个数据页不在内存中，在不影响数据一致性的前提下，先先将更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询这个数据页，将这个数据页读取到内存中，然后执行change buffer中与这个数据页有关的操作（merge）。通过这种方式保存了数据逻辑的正确性。change buffer除了存在于内存中外，还有持久化到磁盘中。

merge操作除了上述情况外，系统也会在后台定期进行merge。在系统进行正常关闭的时候也会进行merge。

而且，读取数据页到内存中是需要占用buffer pool的，所以，这样做也可以提高对内存的利用率。

merge的过程：

1. 从磁盘读入数据页到内存（老版本的数据页）；
2. 从change buffer里找出这个数据页的change buffer记录（可能有多个），依次应用，得到新版数据页。
3. 写redo log，这个redo log包含了数据的变更和change buffer的变更。

到这里merge过程就结束了，这时候数据页和内存中change buffer对应的磁盘位置都还没有修改。之后各自刷回自己的物理数据，就是另外一个过程了。

当然，change buffer 也是需要占用buffer pool的，所以不能无限增大，可以通过innodb_change_buffer_max_size来设置，这个参数为50时，表示最大会使用buffer pool的50%。

那么，对于唯一索引来说，因为必须要判断这个值是否已经存在，就必须需要先将数据页读入内存。既然数据页已经在内存中了，直接操作内存中的数据页更快，change buffer就没必要用了。

因此我们知道，唯一索引是用不上change buffer的。

接下来我们来分析一下，普通索引和唯一索引在插入一个新值时，InnoDB的操作过程：

第一种情况，这个记录要更新的目标页在内存中：

1. 对于唯一索引，找到比插入的新值的第一小的和第一大的之前的位置，判断是否有冲突，如果没有，插入新值，语句执行结束。
2. 对于普通索引，找到比插入的新值的第一小的和第一大的之前的位置，插入新值，语句执行结束。

在数据页在内存的情况下，唯一索引只是多了一个判断，只会耗费微小的CPU时间。

第二种情况，这个记录要更新的数据页不在内存中：

1. 对于唯一索引，需要将数据页读取到内存中，判断是否有冲突，如果没有，插入新值，语句结束。
2. 对于普通索引，将更新记录在change buffer中，语句结束。

将数据从磁盘读入内存涉及到随机IO的访问，是数据库最耗时的操作之一。使用change buffer很明显可以提升数据库的更新性能。



### change buffer 的使用场景

因为merge的时候是真正进行数据更新的时候，而change buffer的目标是先将更新操作缓存下来，所以在一个数据页做merge时，change buffer 中这个数据页的操作越多，收益就越大。

在写多读少的业务下，由于页面写完之后并不会立刻去读，因此效果会比较好。典型的场景有账单类，日志类。

反过来，如果一个页面在写完之后就要马上去读。那么即使满足了条件，先将更新记录在change buffer中，但是由于马上要查询这个数据，马上回触发merge。随机IO访问并没有减少，还需要额外维护change buffer。



### 索引选择和实践

唯一索引和普通索引的查询性能是没有区别的，关键在于更新。建议使用普通索引。

如果业务模式是更新完后会马上获取，那么建议关闭change buffer。

一般来说，在数据量大的时候，普通索引和change buffer 的配合是可以显著提升更新性能的。特点是在机械键盘的情况下。

### change buffer 和 rodo log

简单来说，change buffer主要节省的是随机读磁盘的IO操作，redo log主要减少随机写磁盘的IO操作（改成顺序写）

过程待补充......



思考题：更新change buffer会不会导致数据丢失。

参考答案：不会，虽然只是更新了内存，但是在事务提交的时候回将change buffer的操作也记录到redo log中，所以崩溃的时候可以通过redo log恢复change buffer。
