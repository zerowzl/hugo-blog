---
title: "事务隔离性：为什么你改了我看不见？"
date: 2022-06-15T21:43:48+08:00
draft: false
tag: MySQL
---



### 场景

小明和小兰，转账。转账涉及很多步骤，先查余额、扣余额、加余额。这些步骤需要包含在一个整体中，不然扣余额成功，加余额失败，用户可不同意。而一个余额能被扣多次，银行也不乐意。将这些操作放到事务中，由事务来保证数据的一致性。

### 事务概述

事务存在的目的简单来说就是为了保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中事务是在引擎层实现的。我们知道MySQL是多存储引擎的，MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的原因之一。

### 事务的四大特性（ACID）

- Atomicity 原子性：一个事务的的所有操作要么全部成功要么全部失败。
- Consistency 一致性：保证数据在事务前后的一致性。 eg：小明余额100，小兰余额200，小明转账10元给小兰，要么一致性就保证转账后小兰的余额（90）+小兰的余额（210）= 转账前的100+100 = 200
- Isolation 隔离性：事务之间互不影响
- Durability 持久性：保证事务在执行成功后数据会持久化保存到磁盘中。

### 隔离性和隔离级别

当数据库上同时有多个事务在执行的时候，就可能会出现脏读（dirty read）读到了其他事务没有提交的数据、不可重复读（non-repeatable read）读到的数据前后不一致、幻读（phantom read）无法看到其他事务中新增或者删除的数据 的问题。为了解决这些问题，就有了隔离级别的概念。

- 读未提交（read uncommitted）当前事务能看见其他事务没有提交所做的修改。
- 读已提交（read committed）当前事务能看见其他事务提交所做的修改。
- 可重复读（repeatable read）当前事务每次看见的数据都是一样的，就算其他事务中对数据做了修改，我也看不见。
- 串行化（serializable）当前做的事务没有提交，其他人都需要等我完成。写会加“写锁”读会加“读锁”，当出现读写冲突时，必须等前一个事务完成。

例子：

```sql
create table T(c int) engine = InnoDB;
insert into T(c) vaules(1);
```



![隔离演示](http://localhost:1313/images/7dea45932a6b722eb069d2264d0066f8.png)

在不同的隔离级别下，V1、V2、V3值分别是什么。

- 读未提交V1、V2、V3都是2
- 读已提交V1=1，V2、V3是2
- 可重复读V1、V2 =1，V3=2
- 串行化，当事务B在将1改为2时，会被锁住，必须等事务A提交了事务才能进行下去。所以V1、V2是1，V3是2。

在实现上，在数据库里面会创建一个视图（可以理解是一张静态的表，不受其他事务更新的影响）。“可重复读”是在事务开启时创建的，整个事务存在期间都用这个视图。“读已提交”是在每个SQL语句开始执行的时候创建的，只读已提交事务的数据。“读未提交”没有视图的概念，直接返回记录上的最新值，会读到没有提交事务的数据。“串行化”直接用加锁的方式来避免并行访问。

可以使用

```sql
show variables like 'transaction_isolation';	
```

查看当前事务隔离级别。

存在即合理，每个隔离级别都有自己的适用场景，具体要根据业务场景来定。

### 事务隔离的实现

以“可重复读”说明，实际上每条数据在更新的时候MySQL都会记录一条回滚操作。记录上最新的值，通过回滚操作，可以得到前一个状态的值。

假设一条数据从1被按顺序改成了2、3、4，那么回滚日志中就会有类型下面的记录：

![回滚日志](http://localhost:1313/images/d9c313809e5ac148fc39feff532f0fee.png)



每个事务可以有不同的read-view，同一个数据在数据库中可以有不同的版本，多版本并发控制（MVCC）。假如现在有个事务将4改为了5，也是不影响的。如果当前事务的视图是rad-viewA那么为了得到值1，就需要将当前值依次按回滚日志得到值1。

回滚日志的删除时机：系统会判断如果没有事务需要这些回滚日志时。

什么时候不需要？当系统里没有比这个回滚日志更早的read-view的时候。

可以发现如果数据中有一个长事务，为了得到当前的值，需要一直保留回滚日志，以及运算。会造成大量的日志积压，影响MySQL存储空间。甚至可能因为锁导致拖垮数据库。

### 事务的启动方式

- 显示启动，begin或者start transaction。配套的语句是提交commit 或者回滚 rollback。
- set autocommit = 0，这个命令会将这个线程的自动提交关闭。意味着如果你执行一个select语句，就会开启一个事务，并且不会自动提交。这个事务需要你手动commit 或者rollback，或者断开连接。

建议设置autocommit = 1，显性开启事务，避免长事务。

commit work and chain语句，提交当前事务并开启下一个事务。

长事务保存在information_schema.inndb_trx中。

```sq
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

查询持续时间大于60秒的事务。

### 如果避免长事务

1. set autocommit =1；尽量不要使用长事务。
2. 监控information_schema中的innndb_trx；

参考答案：

##### 应用开发端：

1. 确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1
2. 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。
3. 业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）

##### 数据库：

1. 监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；
2. Percona 的pt-kill 工具。
3. 在业务功能测试阶段要去输出所有肚饿general_log，分析日志行为提前发现问题。
4. 如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。