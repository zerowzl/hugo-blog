---
title: "日志模块：一条更新语句是如何执行的?"
date: 2022-06-15T21:15:48+08:00
draft: false
tag: MySQL
---


### 更新流程是怎样的？有哪些日志模块？是什么层面的？特点和作用是什么？

我们有一张表T，创建语句如下：

```sql
create table T(id int primary key, k int);	
```

更新语句：

```sql
update T set k = k+1 where id = 1;
```



更新语句和查询语句一样，都需要经过连接器、分析器、优化器和执行器。如果有缓存，会将缓存清空。只是为了性能和数据的安全（数据恢复）MySQL并没有每次都将数据直接写入磁盘。使用了一个叫做WAL（write-Ahead-Logging）技术。你可以想象以下场景来更深刻的体会这样的好处。

背景：你是一个饭店的老板，经常有顾客会赊账，因此你除了有一本账本之外还有一块黑板用来在忙的时候进行临时记录赊账。

场景一：如果店里生意很好，赊账的人很多。如果你每次都取出账本，找到顾客的赊账记录然后计算、记录。是不是很麻烦？很费时间？那么在黑板上记录明显就要快很多。

场景二：就算店里不是很忙，赊账的人不是很多。但是相比在账本上找出客人的赊账记录、计算并记录，在黑板上记录是不是更快。

那么，你就可以在空闲的时候（比如打样之后）将黑板的赊账记录记录到账本上。

当然，黑板上的空间是有限的。如果赊账的人很多，导致黑板被写满。就算很忙，你也需要先将黑板上的赊账记录记录到账本上，然后腾出空间给后面的人。而MySQL实现这一点用到的技术就是redo log和binlog。

### redo log 重做日志

我们知道MySQL支持很多存储引擎，redo log就是InnoDB自带的。也就是说如果你用的不是InnoDB，那么就无法使用redo log了。redo log你可以理解成是一个环形的固定大小的文件，有两个指针check print和write pos。

write pos指向当前的写入点，一边写一边往后移。check print是当前要擦除的位置，在擦除记录前要先将记录更新到数据文件。check print和write pos中间的数据是待写入到磁盘的记录，write pos和check print中间的是可以写入的空间。如果write pos追上了check print说明空间被写满了，这时候就需要将数据更新到磁盘中。所以，如果你遇到有时sql很忙的时候，也许MySQL就在做这个事情。

有了redo log，InnoDB就可以保证及时数据库发生了异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。就算数据库重启了，我们也可以通过redo log中的记录恢复数据。

redo log记录的是“做了什么改动”；

### binlog 归档日志

binlog是MySQL自带的，存在于server层的，所以无论你使用哪个引擎，都会有binlog，你可以使用binlog来进行数据的恢复。binlog是追加型的，不会将之前的记录覆盖掉。

binlog有两种模式。statement格式的话记sql语句，row格式（常用）会记录行的内容，记两天，更新前和更新后。

binlog没有crash-safe功能。

### redo log 和 binlog 的不同点

1. rodo log是InnoDB特有的，binlog是server层实现的，所有引擎都可以使用。
2. redo log是物理日志，记录的是“在某个数据库上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给Id=1 这一行的k字段加1”。
3. rode log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换下一个，并不会覆盖以前的日志。

### 更新流程

![更新流程](http://www.zerowzl.com/images/update.png)

1. 因为优化器决定了使用id这个索引，通过搜索树拿到id为1的这一行数据，如果在内存中直接返回，如果不在就先将数据写入内存中返回。
2. 执行器将k+1，如果原来的值为n，那么现在的值就是n+1，然后调用引擎接口写入新行
3. InnoDB将新的数据更新到内存，同时将这个更新操作记录到redo log，处于prepare阶段，然后告知执行器完成了，随时可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘，
5. 执行器执行引擎的提交事务接口，将redo log中的记录修改为commit阶段，更新完成。

### 两阶段提交

我们发现在写入redo log 和binlog时需要经历三个步骤，这里用到了两阶段提交（因为rodo log和binlog是两个独立的逻辑）。为了说明两阶段的意义，我们来设想一下这个场景：你的系统会定期做整库备份，可以是一周一次，也可以是一天一次。取决于系统的重要性。假如说，你的数据库在今天中午12点发生了误删除，然后你在下午2点发现了，需要找回数据：

- 首先找到最近的一次全量备份，如果运气好，也许就是昨天晚上，从这个备份恢复到临时库中。
- 然后，从备份的时间点开始，将备份的binlog一次取出来，重放到中午12点误删除之前的那个时间。

这时候临时库就和12点前误删除之前的一样了，然后就可以按需进行恢复。当然，这中间两个小时的数据，你可能需要人工进行处理一下。

以上是正常的，可以使用binlog进行恢复的。如果没有两阶段提交，先写一个再写另一个我们来看看会发生什么。以之前的更新语句为例子update T set k = k+1 where id =1，将设k原来的值是0；

- **先写redo log再写binlog** 如果在rodo log写完，bin log没有写入时发生了数据库重启。那么由于rodo log有crash-safe能力，会将k的值恢复为1。但是由于binlog每次记录这次的更新，如果下次使用binlog用来恢复数据，k就会是0。那么数据就会出现不一致的情况。
- **先写binlog再写redo log** 如果在binlog写完，redo log写入前发生了数据库崩溃，由于redo log中没有记录，k还是0，但是binlog中已经记录了本次修改，那么如果下次使用binlog进行数据恢复，k就会是1。数据不一致。

简而言之，redo log和binlog都可以用于表示事务的提交状态，两阶段提交就是为了让这两个状态保持逻辑上的一致。

这里说下在两阶段提交过程发生崩溃时，MySQL是是否保证数据一致性的。

一）redo log prepare阶段  二）写入binlog 三）redo log commit阶段

- 在一发生崩溃，都没有记录，数据一致
- 在二发生崩溃，redo log查看记录是prepare阶段，没有binlog回滚
- 在三发生崩溃，redo log查看记录是prepare阶段，有binlog，提交。

### 恢复数据的场景

- 误操作
- 扩容，增加从库提高读能力，一般主流的做法也是用全量备份加上应用binlog

