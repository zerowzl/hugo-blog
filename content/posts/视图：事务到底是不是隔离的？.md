---
title: "视图：事务到底是不是隔离的？"
date: 2022-06-15T21:45:48+08:00
draft: false
tag: MySQL
---

### 场景

我们知道在RR的隔离级别下，会在事务启动时（实际是在事务启动之后第一次操作InnoDB表的语句（第一个快照读语句）事务才真正启动，使用start transaction with consistent snapshot可以保证马上获取到一致性视图）创建一个视图read-view。之后该事务的操作都是基于这个视图来的，即他能看见什么。

但是，当多个事务对一行数据都有更新时，就不能这样了。不然数据就乱了。那么MySQL是如何做的呢？案例：

```sql
CREATE TABLE `t` (
	`id` int(11) NOT NULL,
	`k` int(11) DEFAULT NULL,
  	PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);	
```

![可重复读多事务示意图](http://localhost:1313/images/1548060191740.jpg)

注意，这里的autocommit=1，transactionC这个udpate语句本身就是一个事务，并且更新完id为1的这一行后就立即提交了。然后transactionB也去更新id为1的这一行将k值再次加一，然后去读。接着就是transactionA去读id为1的这一行数据，提交事务。最后transactionB提交事务。那么transactionA和transactionB在读id为1的这行数据时读出来的分别是多少呢？

transactionA因为开启了事务，那么根据RR的隔离级别的作用，transactionA的读都是基于一开始的一致性读视图的。所以A读到的k是1。transactionB读到的是k在分别加了两次1后的结果，也就是3。那么MySQL是如何做到这一点的呢？

首先要先明白下面这两个概念：

### view

视图，就是用查询语句定义的的虚拟表，可以使用create view view_name …创建，对该视图的语法和查询语法一样。

### consistent read view

一致性读视图，是InnoDB在实现MVCC（多版本并发控制）用到的，用来支持读已提交RC（read committed）和RR（repeatable read，可重复读）隔离级别的实现。它**没有物理构造，作用是事务在执行期间用来定义“我能看见什么数据。**

### “快照”在MVCC中是如何工作的？

在可重复读的隔离级别下，事务在启动的时候就拍了一个“快照”，这个快照是基于库的。

InnoDB中每个事务都有一个**事务ID transaction Id**，在事务启动的时候向InnoDB事务系统申请的，这个事务Id是按照申请顺序严格递增的。

而每行数据是存在有多个版本的。每次更新的时候都会生成一个新的版本，并且把事务id赋值给这个数据版本的事务id，记为 row trx_id ，同时旧的版本需要保留，并且在新的数据版本中，能够有信息可以拿到他。通过最新版本+undo log计算出之前版本的值。

也就是说，数据库表的每一行数据，其实可能有多个版本（row），每个版本对应一个row trx_id;

下图是一行数据连续被更新的示意图：

![数据变更示意图](http://localhost:1313/images/8A66AEC1-AE03-4470-831E-547CDAB9093D.png)

如图所示，每个数据的版本有row trx_id（修改的事务id）以及可以通过undo log获取前一个版本的数据。那么为了实现事务一致性读视图，InnoDB中还有一个很关键的东西，**视图数据**。

根据可重复读的定义，一个事务启动时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它是不可见的。因此，一个事务只需要在事务启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，我就认；如果是我启动之后生成的，我就不认。”

InnoDB的一个事务在启动的瞬间，会将当前系统中活跃的事务（已创建还未提交的事务）使用一个数组来记录下。当前系统中最小的事务id作为低水位，最大的事务id+1作为高水位（这是一个原子操作，在此期间不会发生有新的事务产生但没有记录下来的情况）。使用这个视图数组和高水位概念就组成了当前事务的一致性读视图（read-view）。而数据版本的可见性规则，就是基于数据的row trx_id 和这个一致性读视图的对比结果得到的。

这个视图数组将一个row trx_id 分成了以下几种情况：

![row trx_id 分布示意图](http://localhost:1313/images/01596A99-5CE1-4FBB-8E4C-987181F4A525.png)

1. 如果落在黄色部分（小于低水位，不在视图数组中），表示这个版本是已提交或者当前事务自己生成，这个数据是可见的。
2. 如果落在红色部分（高于高水位，不在视图数组中），表示这个版本是由将来启动的事务生成的，这个数据是不可见的。
3. 如果落在绿色部分有两种情况
   1. 若row trx_id在数组中，表示这个版本的事务由还没提交的事务生成的，这个数据是不可见的。
   2. 若row trx_id不在数组中，表示这个版本是由已经提交的事务生成的，这个数据是可见的。

带入到上图中，假如当前的事务id是7，那么获取到最新的数据行发现版本号（row trx_id）是9，比当前的事务id要大，他就不认，通过undo log获取到上一个版本的数据，发现row trx_id 是6，拿到k=4。有了这个声明，我们可以看到，对于在当前事务后更新的数据肯定是属于2或者3.1的情况，对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是静态的。InnoDB利用**所有数据都有多个版本**这个特性，**实现了秒级创建快照的能力**。

### 查询逻辑

根据上面介绍几个特性，我们来分析一下图1中事务A的k为什么是1。

假设：

1. 事务A开启时，系统中只有一个活跃的事务ID是99；
2. 事务A、B、C的事务ID分为是100，101，102，且当前系统中只有这四个事务；
3. 三个事务开始前，(1,1)这一行的数据row trx_id是90；

这样，事务A的视图数组就是[99,100]，事务B的视图数组就是[99,100,101]，事务C的视图数组就是[99,100,101,102]。

事务C首先将(1,1)更新为(1,2)，这时的数据版本对应的是事务C的事务id103，然后是事务B将(1,2)更新为(1,3)，数据版本变为事务B的事务id101，虽然事务B的事务没有提交，但是数据版本已经生成了。（这里插一句，本来还有疑问担心事务没有提交，数据版本已经生成，如果有其他事务对这个值进行更新然后之前的事务如果做了回滚会不会导致数据混乱，但是学了InnoDB的行锁之后我们知道，第一个事务更新了如果没有提交或者回滚，那么会一直持有的这一行数据的行锁。其他事务要修改这一行数据会被阻塞住，不会出现上面的顾虑。那么看来InnoDB的行锁两阶段协议还有很有必要的。）这时事务A来查询了，读数据都是从当前版本读起的。流程如下：

1. 找到(1,3)的时候，判断出row trx_id =101，比高水位大，处于红色区域，不可见。
2. 接着，通过undo log找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见。
3. 再往前找，找到row trx_id=90的版本，比低水位要低，处于黄色区域，可见。

这样执行下去，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到的数据都是一致的。我们称为一致性读。

上面的逻辑是根据代码直接翻译的，可以简化如下：

1. 版本未提交，不可见。
2. 版本已提交，但是是在视图创建之后更新的，不可见。
3. 版本已提交，是在视图创建之前更新的，可见。

### 更新逻辑

更新数据和查询数据最大的不同是，**更新操作都是先读后写的，而这个读，只能读当前的值，称为当前读（current read）**。这样是为了防止不让其他事务做的更新丢失。

因此，在事务B更新数据时读到最新的值(1,2)row trx_id=102，然后更新为(1,3)row trx_id=101。然后再去查询这一行记录一看row trx_id=101，自己的row trx_id也是101，可以用。

当前读除了update语句外，select 语句如果加锁，也是当前读。

lock in share mode(S锁，共享锁)，for update（X锁，排它锁，也就是我们常说的悲观锁）

```sql
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```



### 读提交

读提交和可重复的区别：

- 可重复读的隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务中的其他查询都共用这个一致性视图。
- 读提交的隔离级别下，每一个语句执行前都会重新算出一个新的视图（因为事务期间可能会有其他事务提交）。

”start transaciton with consistent snapshot“在读提交下是无效的，等效于普通的begin/start transaction。我们来看下图1在读提交下的k分别是多少。

事务A是在事务B、C分别修改后值查询的，时间上，更新的两个数据版本都在视图创建之前。但是：

- (1,3)还没提交，属于情况1，不可见。
- (1.2)已提交，属于情况3，可见。

那么，是不是说只写一个视图数组还是不够的，还必须知道这个事务是否已经提交？或者是时间？

### 表结构的可重复读？

因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读。不过在MySQL8.0已经可以把表结构放在InnoDB的字典表了，也许以后会支持表结构的可重复读。



思考题：

```sql
CREATE TABLE `t3` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);
```

建表语句如上，隔离级别是可重复读。现在需要将所有k=id的行数据的c清零，但是却出现了一个改不掉的情况。

复现：

![更新失败示意图](http://localhost:1313/images/64B6CEFA-D25E-4C52-BB5D-ADE60D108F9E.png)

只需要再开一个事务将c值修改掉就可以，比如先执行一次update T3 set c = 0 where id =c；这个c已经变成0了。再去update时，是当前读拿到c=0，不等于id。select * from T3时遵循可重复读的规则，后面事务做的更新不可见，拿到的还是之前的值。这个对应的就是情况2，版本已提交，但是是在视图创建后更新的。

当然，还有一种情况：在当前事务之前还有一个活跃事务B，如果B在当前事务更新前更新了数据，并提交了。其实事务B 的事务id是落在了绿色区域（上面的情况是属于高于高水位的红色区域），是3.1的情况。也是不可见的。

这个感觉像是乐观锁（CAS），当发现修改行数时0时，应该重新开启事务做一次。

